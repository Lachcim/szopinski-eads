\documentclass{article}

\title{
	Singly-linked list of two data types \\
	\large An EADS generic programming project report
}
\date{November 2019}
\author{Michał Szopiński}

\begin{document}

\maketitle

\section{Overview}

The goal of the project was to write a singly-linked list of nodes capable of
storing data entries consisting of two different data types, labeled {\it key} and {\it info}.
This was to be achieved using the class template mechanism offered by the C++
programming language. The end goal was to design a container class whose public
members would facilitate the implementation of a function named {\tt split},
which divides the container into two smaller ones, following a set of rules.

The container in question is named {\tt Sequence} and can be used as follows:

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.add("key 1", 123);
mySequence.add("key 2", 456);
mySequence.add("key 3", 789);
mySequence.remove(1);
\end{verbatim}

The above code allocates a new instance of {\tt Sequence} on the stack,
adds three elements to it, and then promptly removes the second element.
This particular instance is capable of holding keys of type {\tt const char*}
and info of type {\tt int}.

There are many other methods and members of the {\tt Sequence} class template
which can be used to manipulate the container.

\subsection{Memory management considerations}

One of the key design features of the container is that it creates copies
of the elements passed into it and allocates them on the heap, automatically
managing them throughout its lifespan. While useful for storing multiple instances
of independent objects, developers must be wary of this feature if they intend
to store classes that are memory-intensive.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer> mySequence;
mySequence.add(1, buffer);
mySequence.add(2, buffer);
mySequence.add(3, buffer); //100 MB allocated on the heap by 4
                           //instances of ImageBuffer
\end{verbatim}

As shown above, improper use of {\tt Sequence} can easily lead to excessive
memory usage. When object independence isn't necessary, it may be preferable
to create a sequence of pointers instead.

\begin{verbatim}
Sequence<int, ImageBuffer*> mySequence;
mySequence.add(1, &buffer);
mySequence.add(2, &buffer);
mySequence.add(3, &buffer); //25 MB allocated on the heap by 1
                            //instance of ImageBuffer
\end{verbatim}

\subsection{Tail keeping mechanism and iterators}

In order to facilitate bulk insertion, a tail keeping mechanism was implemented
to keep track of the last element on the list. This reduced the time complexity
of final-element insertion from $O(n)$ (resulting from the need to traverse the
entire list) to $O(1)$. This, however, did not reduce the complexity of
final-element removal, which could only be improved by implementing a doubly-linked
list.

As a result of this disparity between accessing final and non-final elements,
an iterator class was added to the container to enable fast access to subsequent
nodes. {\tt Sequence<Key, Info>::iterator} is therefore a forward iterator
which can be used to efficiently traverse the list with a complexity of $O(n)$,
as opposed to $O(n^2)$ that's associated with continuous calls to {\tt get()}.

\begin{verbatim}
//a sequence of 100000 elements
Sequence<int, int> mySequence;
for (int i = 0; i < 100000; i++)
    mySequence.add(i, i);

for (int i = 0; i < 100000; i++)
    mySequence.get(i, output); //5050555500 queries

Sequence<int, int>::iterator i;
for (i = mySequence.begin(); i != mySequence.end(); ++i)
    output = *i; //100000 queries
\end{verbatim}

\subsection{Template implementation detail}

A minor implementation detail is how template implementation was separated from
the declaration. Readers of the source code might be surprised at the presence
of {\tt \#include} statements at the end of some header files. This was done to work
around C++'s requirement of exposing the implementation to all classes that wish to
use the template. To keep source code separate from class definitions, all declarations
were put in {\bf .h} files, all implementations were put in {\bf .hpp} files, and the
latter were appended to the former.

\end{document}
