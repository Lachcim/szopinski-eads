\documentclass{article}

\title{
	Singly-linked list of two data types \\
	\large An EADS generic programming project report
}
\date{November 2019}
\author{Michał Szopiński}

\begin{document}

\maketitle

\section{Overview}

The goal of the project was to write a singly-linked list of nodes capable of
storing data entries consisting of two different data types, labeled {\it key} and {\it info}.
This was to be achieved using the class template mechanism offered by the C++
programming language. The end goal was to design a container class whose public
members would facilitate the implementation of a function named {\tt split},
which divides the container into two smaller ones, following a set of rules.

The container in question is named {\tt Sequence} and can be used as follows:

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.add("key 1", 123);
mySequence.add("key 2", 456);
mySequence.add("key 3", 789);
mySequence.remove(1);
\end{verbatim}

The above code allocates a new instance of {\tt Sequence} on the stack,
adds three elements to it, and then promptly removes the second element.
This particular instance is capable of holding keys of type {\tt const char*}
and info of type {\tt int}.

There are many other methods and members of the {\tt Sequence} class template
which can be used to manipulate the container.

\subsection{Memory management considerations}

One of the key design features of the container is that it creates copies
of the elements passed into it and allocates them on the heap, automatically
managing them throughout its lifespan. While useful for storing multiple instances
of independent objects, developers must be wary of this feature if they intend
to store classes that are memory-intensive.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer> mySequence;
mySequence.add(1, buffer);
mySequence.add(2, buffer);
mySequence.add(3, buffer); //100 MB allocated on the heap by 4
                           //instances of ImageBuffer
\end{verbatim}

As shown above, improper use of {\tt Sequence} can easily lead to excessive
memory usage. When object independence isn't necessary, it may be preferable
to create a sequence of pointers instead.

\begin{verbatim}
Sequence<int, ImageBuffer*> mySequence;
mySequence.add(1, &buffer);
mySequence.add(2, &buffer);
mySequence.add(3, &buffer); //25 MB allocated on the heap by 1
                            //instance of ImageBuffer
\end{verbatim}

\subsection{Tail keeping mechanism and iterators}
\subsection{Template implementation detail}

\end{document}
