\documentclass{article}

\title{
	Singly-linked list of two data types \\
	\large An EADS generic programming project report
}
\date{November 2019}
\author{Michał Szopiński}

\begin{document}

\maketitle

\section{Overview}

The goal of the project was to write a singly-linked list of nodes capable of
storing data entries consisting of two different data types, labeled {\it key}
and {\it info}. This was to be achieved using the class template mechanism
offered by the C++ programming language. The end goal was to design a container
class whose public members would facilitate the implementation of a function
named {\tt split}, which divides the container into two smaller ones, following
a set of rules.

The container in question is named {\tt Sequence} and can be used as follows:

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.add("key 1", 123);
mySequence.add("key 2", 456);
mySequence.add("key 3", 789);
mySequence.remove(1);
\end{verbatim}

The above code allocates a new instance of {\tt Sequence} on the stack,
adds three elements to it, and then promptly removes the second element.
This particular instance is capable of holding keys of type {\tt const char*}
and info of type {\tt int}.

There are many other methods and members of the {\tt Sequence} class template
which can be used to manipulate the container.

\subsection{Memory management considerations}

One of the key design features of the container is that it creates copies
of the elements passed into it and allocates them on the heap, automatically
managing them throughout its lifespan. While useful for storing multiple
instances of independent objects, developers must be wary of this feature if
they intend to store classes that are memory-intensive.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer> mySequence;
mySequence.add(1, buffer);
mySequence.add(2, buffer);
mySequence.add(3, buffer); //100 MB allocated on the heap by 4
                           //instances of ImageBuffer
\end{verbatim}

As shown above, improper use of {\tt Sequence} can easily lead to excessive
memory usage. When object independence isn't necessary, it may be preferable
to create a sequence of pointers instead.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer*> mySequence;
mySequence.add(1, &buffer);
mySequence.add(2, &buffer);
mySequence.add(3, &buffer); //25 MB allocated on the heap by 1
                            //instance of ImageBuffer
\end{verbatim}

\subsection{Tail keeping mechanism and iterators}

In order to facilitate bulk insertion, a tail keeping mechanism was implemented
to keep track of the last element on the list. This reduced the time complexity
of final-element insertion from $O(n)$ (resulting from the need to traverse the
entire list) to $O(1)$. This, however, did not reduce the complexity of
final-element removal, which could only be improved by implementing a
doubly-linked list.

As a result of this disparity between accessing final and non-final elements,
an iterator class was added to the container to enable fast access to subsequent
nodes. {\tt Sequence<Key, Info>::iterator} is therefore a forward iterator
which can be used to efficiently traverse the list with a complexity of $O(n)$,
as opposed to $O(n^2)$ that's associated with continuous calls to {\tt get()}.

\begin{verbatim}
//a sequence of 100000 elements
Sequence<int, int> mySequence;
for (int i = 0; i < 100000; i++)
    mySequence.add(i, i);

for (int i = 0; i < 100000; i++)
    mySequence.get(i, output); //5050555500 queries

Sequence<int, int>::iterator i;
for (i = mySequence.begin(); i != mySequence.end(); ++i)
    output = *i; //100000 queries
\end{verbatim}

\subsection{Template implementation detail}

A minor implementation detail is how template implementation was separated from
the declaration. Readers of the source code might be surprised at the presence
of {\tt \#include} statements at the end of some header files. This was done to
work around C++'s requirement of exposing the implementation to all classes that
wish to use the template. To keep source code separate from class definitions,
all declarations were put in {\bf .h} files, all implementations were put in
{\bf .hpp} files, and the latter were appended to the former.

\section{Template specification}

In the following section, function signatures are written in shorthand -
omitting the data types of their parameters, the scope resolution operators and
the template syntax.

\subsection{Private members}

\subsubsection{{\tt struct SequenceNode}}

A building block for the linked list. It consists of a {\tt KeyInfoPair} struct
to store the data and a pointer to another {\tt SequenceNode} to maintain the
link.

\subsubsection{{\tt SequenceNode* head}}

A pointer to the first element in the linked list. Basic element of all linked
lists.

\subsubsection{{\tt SequenceNode* tail}}

A pointer to the last element in the linked list. Enables quick insertion at the
end of the list.

\subsubsection{{\tt int size}}

An integer representing the number of currently stored elements. Reduces time
complexity of size queries.

\subsubsection{{\tt void copyList(other)}}

Copies the entire contents of a different sequence and appends them at the end
of this sequence. Probes the number of nodes to be copied once to allow
self-duplication.

\subsubsection{{\tt void deleteList()}}

Deallocates all nodes on the list. The sequence remains in a valid state and can
be reused after this method is called.

\subsubsection{{\tt SequenceNode* createNode(key, info)}}

A helper function to create nodes in one line. Allocates a new
{\tt SequenceNode} on the heap, assigns values to its members, and returns a
pointer to the newly allocated object.

\subsection{Public members}

\subsubsection{{\tt struct KeyInfoPair}}

A structure holding the key and the info of a given node. Value type of the
iterator.

\subsubsection{{\tt Sequence()}}

Default constructor. Creates an empty list.

\subsubsection{{\tt Sequence(other)}}

Copy constructor. Copies all elements of the other list.

\subsubsection{{\tt \~{}Sequence()}}

Destructor. Deallocates all nodes on the list.

\subsubsection{{\tt class iterator}}

An forward input-output iterator that allows the list to be traversed with
$O(n)$ complexity.

\subsubsection{{\tt iterator begin()}}

An iterator pointing to the head of the list.

\subsubsection{{\tt iterator end()}}

An iterator marking the end of the list. Internally, a null pointer.

\subsubsection{{\tt Sequence\& operator=(other)}}

Copy assignment operator. Deallocates all nodes of this list and copies all
nodes from the other list.

\subsubsection{{\tt Sequence operator+(other)}}

Sum operator. Creates a new sequence combining its two operands.

\subsubsection{{\tt Sequence\& operator+=(other)}}

Addition assignment operator. Adds all nodes of the other sequence to this one.

\subsubsection{{\tt void add(key, info)}\\
{\tt void add(keyInfoPair)}}

Adds a new node at the end of the list.

\subsubsection{{\tt bool add(key, info, index)}\\
{\tt bool add(keyInfoPair, index)}}

Adds a new node at the given index. Returns true on success.

\subsubsection{{\tt bool add(sequence)}}

Appends the given sequence at the end of this list. Returns true if at least one
element was appended.

\subsubsection{{\tt bool get(index, outputKey, outputInfo)}\\
{\tt bool get(index, outputKeyInfoPair)}}

Retrieves the element at the given index. Returns true on success.

\subsubsection{{\tt bool remove()}}

Removes the last element from the list. Returns true if the list wasn't empty.

\subsubsection{{\tt bool remove(index)}}

Removes the element with the given index from the list. Returns true on success.

\subsubsection{{\tt int getSize()}}

Retrieves the size of the list with $O(1)$ complexity.

\section{Implementation of the {\tt split} function}

With the help of the aforementioned features, it was possible to implement the
{\tt split} function in an efficient and elegant manner. Linear-time list
traversal combined with constant-time final insertion reduced the
time-complexity of {\tt split} to $O(n)$.

\subsection{Input}

The function accepts the following input parameters:

\begin{itemize}
\item {\tt const Sequence<Key, Info>\& source} - The sequence to be split
\item {\tt int start} - The number of initial entries to be omitted
\item {\tt Sequence<Key, Info>\& dest1} - The first output sequence
\item {\tt int step1} - The number of entries to be copied to dest1 per turn
\item {\tt int count1} - The number of turns when elements are copied to dest1
\item {\tt Sequence<Key, Info>\& dest2} - The second output sequence
\item {\tt int step2} - The number of entries to be copied to dest2 per turn
\item {\tt int count2} - The number of turns when elements are copied to dest2
\end{itemize}

\subsection{Output}

\begin{enumerate}
\item The initial {\tt start} elements are not to be copied anywhere.

\item  Past the initial {\tt start} elements, sequence nodes are to be copied
interchangeably to {\tt dest1} and {\tt dest2}, starting with the former.

\item  If {\tt count1} is 0 and it's {\tt dest1}'s turn, {\tt dest1} skips its
turn. The same applies to {\tt dest2}.

\item  If it's {\tt dest1}'s turn, {\tt step1} elements are to be copied to
{\tt dest1}. If there are not enough elements in {\tt source}, the maximum
possible amount of elements is copied and the algorithm terminates.
The same applies to {\tt dest2}.

\item  If it's {\tt dest1}'s turn, {\tt count1} is decremented. The same applies
to {\tt dest2}.

\item If both {\tt count1} and {\tt count2} are zero, the algorithm terminates.
\end{enumerate}

\subsection{Implementation}

The algorithm used to implement the function can be described as follows
(using pseudocode):

\begin{verbatim}
01 if start is greater or equal to source's length, terminate

02 obtain iterator of source at the beginning

03 increment iterator to start position

04 mark dest1 as output destination

05 if count1 > 0 or count2 > 0, continue, otherwise terminate

06 if outputting to dest1 and count1 is 0, go to 10
   if outputting to dest2 and count2 is 0, go to 10
   
07 if outputting to dest1, try to output step1 elements to dest1
   if outputting to dest2, try to output step2 elements to dest2

08 if end of source was reached mid-way, terminate

09 if outputting to dest1, decrement count1
   if outputting to dest2, decrement count2

10 switch output destination

11 go to 05

\end{verbatim}

\subsection{Example program output}

The following constitutes example program output, with line breaks inserted
for formatting.

\begin{verbatim}
Original sequence:
Key:  stays stays stays   dest1 dest1 dest2 dest2 dest2 dest1 
Info: 123   12345 1234567 31415 27182 2137  69    420   16180 

dest1 dest2 dest2 dest2 dest2 dest2
14142 1352  911   404   1337  8008135

Splitting: starting at 3, 2 elements to dest1 2 times,
3 elements to dest2 3 times

Destination 1:
Key:  dest1 dest1 dest1 dest1
Info: 31415 27182 16180 14142

Destination 2:
Key:  dest2 dest2 dest2 dest2 dest2 dest2 dest2 dest2
Info: 2137  69    420   1352  911   404   1337  8008135
\end{verbatim}

\end{document}
