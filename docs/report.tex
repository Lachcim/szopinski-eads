\documentclass{article}

\title{
	Keyed singly-linked list of two data types \\
	\large An EADS generic programming project report
}
\date{November 2019}
\author{Michał Szopiński}

\begin{document}

\maketitle

\section{Overview}

The goal of the project was to write a singly-linked list of nodes which would
emulate a collection of independent sequences, each distinguished with a unique
key. This was to be achieved using the class template mechanism offered by the
C++ programming language. The end goal was to design a container class whose
public members would facilitate the implementation of a function named
{\tt split}, which divides the container into two smaller ones, following
a set of rules.

The container in question is named {\tt Sequence} and can be used as follows:

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.push_back("my key", 123);
mySequence.push_back("my key", 456);
mySequence.push_back("my key", 789);
mySequence.erase(++(mySequence.begin("my key")));
\end{verbatim}

The above code allocates a new instance of {\tt Sequence} on the stack,
adds three elements to it, and then promptly removes the second element.
This particular instance is capable of holding keys of type {\tt const char*}
and info of type {\tt int}.

\subsection{The key-info mechanism and sublists}

The significance of the {\it key} parameter is that it groups elements together,
effectively separating the sequence into multiple independent lists, henceforth
called {\it sublists}. The modifiers provided by the class can therefore either
operate on one individual sublist, or all of them at once. As such, most public
members of {\tt Sequence} provide a parameter of type {\tt const Key\&}, which
is used to specify the key of the sublist that is to be modified. Some members,
such as {\tt size()}, provide no such parameter and operate on all sublists
simultaneously.

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.push_back("my key", 123);
mySequence.push_back("my key", 456);
mySequence.push_back("my key", 789);
mySequence.push_back("your key", 1234);
mySequence.push_back("your key", 1234);
mySequence.push_back("your key", 1234);
mySequence.clear("my key");
\end{verbatim}

In the above code, {\tt "my key"} was the only key impacted by the {\tt clear()}
method. After the final statement, three elements remain in the sequence - all
of which belonging to the sublist {\tt "your key"}.

\subsection{Key comparability and other requirements}

Because the class template mechanism allows all classes to be used as keys and
info entries, care must be taken to only use classes which are suitable for
this task. A suitable class is a class that meets all of the following criteria:

\begin{enumerate}
\item In the case of keys, two instances of the class can be meaningfully
compared using the {\tt ==} and {\tt !=} operators.
\item It has a default constructor of no parameters.
\item It has an effective copy constructor and a copy assignment operator.
\end{enumerate}

Failure to meet these criteria may produce unpredictable results or prevent
compilation altogether.

\subsection{Tail keeping mechanism and iterators}

In order to facilitate bulk insertion, a tail keeping mechanism was implemented
to keep track of the last element on the list. This reduced the time complexity
of final-element insertion from $O(n)$ (resulting from the need to traverse the
entire list) to $O(1)$. This, however, did not reduce the complexity of
final-element removal, which could only be improved by implementing a
doubly-linked list.

As a result of this disparity between accessing final and non-final elements,
an iterator class was added to the container to enable fast access to
consecutive nodes. {\tt Sequence<Key, Info>::iterator} is therefore a forward
iterator which can be used to efficiently traverse the list with a complexity of
$O(n)$, as opposed to $O(n^2)$ that's associated with continuous calls to
{\tt at()}.

\begin{verbatim}
//a sequence of 100000 elements
Sequence<const char*, int> mySequence;
for (int i = 0; i < 100000; i++)
    mySequence.add("my key", i);

for (int i = 0; i < 100000; i++)
    output = mySequence.at("my key", i); //5050555500 queries

Sequence<const char*, int>::iterator i;
for (i = mySequence.begin("my key"); i != mySequence.end(); ++i)
    output = *i; //100000 queries
\end{verbatim}

{\tt Sequence<Key, Info>::const\_iterator} is a constant version of this
iterator which does not permit any changes to the iterated sequence.

\subsection{Keyed and key-agnostic iterators}

Despite the fact that {\tt Sequence} is inherently designed to treat all of its
sublists independently, the requirements of the final task demanded that a
special interface is introduced to treat the sequence as a unitary "superlist".
This interface is known as a {\it key-agnostic iterator} and can be used to
transcend the boundaries of sublists when iterating over the sequence.
Like most public members of the class, iterators posses a parameter which limits
them to a single sublist: 

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.push_back("my key", 123);
mySequence.push_back("your key", 1234);
mySequence.push_back("his key", 4321);
mySequence.push_back("my key", 123);
mySequence.push_back("your key", 1234);
mySequence.push_back("his key", 4321);
mySequence.push_back("my key", 123);
mySequence.push_back("your key", 1234);
mySequence.push_back("his key", 4321);

Sequence<const char*, int>::iterator it;
for (it = mySequence.begin("his key"); it != mySequence.end(); ++it)
    printf("%s %d\n", it->key, it->info);
    //prints "his key 4321" three times

\end{verbatim}

A similar call to {\tt begin()} (without the parentheses) would return a
key-agnostic iterator, which would then produce nine different lines in the
output stream.
A key-agnostic iterator cannot be used to insert new elements with the
{\tt insert(iterator, const Info\&)} method, as it is not related to any sublist
and carries no information about its key. Similarly, the iterator returned by
{\tt end()} is also key-agnostic and cannot be used to push new elements to
the end of the list. In order to generate a keyed end iterator,
{\tt end(const Key\&)} can be called, which in turn can be used for insertion:

\begin{verbatim}
mySequence.insert(mySequence.end("her key"), 777);
\end{verbatim}

Despite these differences, however, all end iterators, keyed or not, compare
true to each other.

\begin{verbatim}
mySequence.end("her key") == mySequence.end() //true
\end{verbatim}

\subsection{Memory management considerations}

One of the key design features of the container is that it creates copies
of the elements passed into it and allocates them on the heap, automatically
managing them throughout its lifespan. While useful for storing multiple
instances of independent objects, developers must be wary of this feature if
they intend to store classes that are memory-intensive.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer> mySequence;
mySequence.push_back(1, buffer);
mySequence.push_back(2, buffer);
mySequence.push_back(3, buffer); //100 MB allocated on the heap by
                                 //four instances of ImageBuffer
\end{verbatim}

As shown above, improper use of {\tt Sequence} can easily lead to excessive
memory usage. When object independence isn't necessary, it may be preferable
to create a sequence of pointers instead.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer*> mySequence;
mySequence.push_back(1, &buffer);
mySequence.push_back(2, &buffer);
mySequence.push_back(3, &buffer); //25 MB allocated on the heap by
                                  //one instance of ImageBuffer
\end{verbatim}

\section{Template specification}

In the following section, function signatures are written in shorthand -
omitting the data types of their parameters, the scope resolution operators and
the template syntax.

\subsection{Private members}

\subsubsection{{\tt struct SequenceNode}}

A building block for the linked list. It consists of a {\tt KeyInfoPair} struct
to store the data and a pointer to another {\tt SequenceNode} to maintain the
link.

\subsubsection{{\tt SequenceNode* head}}

A pointer to the first element in the linked list. Basic element of all linked
lists.

\subsubsection{{\tt SequenceNode* tail}}

A pointer to the last element in the linked list. Enables quick insertion at the
end of the list.

\subsubsection{{\tt int size}}

An integer representing the number of currently stored elements. Reduces time
complexity of size queries.

\subsubsection{{\tt void copyList(other)}}

Copies the entire contents of a different sequence and appends them at the end
of this sequence. Probes the number of nodes to be copied once to allow
self-duplication.

\subsubsection{{\tt void deleteList()}}

Deallocates all nodes on the list. The sequence remains in a valid state and can
be reused after this method is called.

\subsubsection{{\tt SequenceNode* createNode(key, info)}}

A helper function to create nodes in one line. Allocates a new
{\tt SequenceNode} on the heap, assigns values to its members, and returns a
pointer to the newly allocated object.

\subsection{Public members}

\subsubsection{{\tt struct KeyInfoPair}}

A structure holding the key and the info of a given node. Value type of the
iterator.

\subsubsection{{\tt Sequence()}}

Default constructor. Creates an empty list.

\subsubsection{{\tt Sequence(other)}}

Copy constructor. Copies all elements of the other list.

\subsubsection{{\tt \~{}Sequence()}}

Destructor. Deallocates all nodes on the list.

\subsubsection{{\tt class iterator}}

An forward input-output iterator that allows the list to be traversed with
$O(n)$ complexity.

\subsubsection{{\tt iterator begin()}}

An iterator pointing to the head of the list.

\subsubsection{{\tt iterator end()}}

An iterator marking the end of the list. Internally, a null pointer.

\subsubsection{{\tt class const\_iterator}}

A constant version of {\tt iterator}, cannot be used to modify the sequence.

\subsubsection{{\tt const\_iterator cbegin()}}

An constant iterator pointing to the head of the list.

\subsubsection{{\tt const\_iterator cend()}}

An constant iterator marking the end of the list. Internally, a null pointer.

\subsubsection{{\tt Sequence\& operator=(other)}}

Copy assignment operator. Deallocates all nodes of this list and copies all
nodes from the other list.

\subsubsection{{\tt Sequence operator+(other)}}

Sum operator. Creates a new sequence combining its two operands.

\subsubsection{{\tt Sequence\& operator+=(other)}}

Addition assignment operator. Adds all nodes of the other sequence to this one.

\subsubsection{{\tt void add(key, info)}\\
{\tt void add(keyInfoPair)}}

Adds a new node at the end of the list.

\subsubsection{{\tt bool add(key, info, index)}\\
{\tt bool add(keyInfoPair, index)}}

Adds a new node at the given index. Returns true on success.

\subsubsection{{\tt bool add(sequence)}}

Appends the given sequence at the end of this list. Returns true if at least one
element was appended.

\subsubsection{{\tt bool get(index, outputKey, outputInfo)}\\
{\tt bool get(index, outputKeyInfoPair)}}

Retrieves the element at the given index. Returns true on success.

\subsubsection{{\tt bool remove()}}

Removes the last element from the list. Returns true if the list wasn't empty.

\subsubsection{{\tt bool remove(index)}}

Removes the element with the given index from the list. Returns true on success.

\subsubsection{{\tt int getSize()}}

Retrieves the size of the list with $O(1)$ complexity.

\section{Implementation of the {\tt split} function}

With the help of the aforementioned features, it was possible to implement the
{\tt split} function in an efficient and elegant manner. Linear-time list
traversal combined with constant-time final insertion reduced the
time-complexity of {\tt split} to $O(n)$.

\subsection{Input}

The function accepts the following input parameters:

\begin{itemize}
\item {\tt const Sequence<Key, Info>\& source} - The sequence to be split
\item {\tt int start} - The number of initial entries to be omitted
\item {\tt Sequence<Key, Info>\& dest1} - The first output sequence
\item {\tt int step1} - The number of entries to be copied to dest1 per turn
\item {\tt int count1} - The number of turns when elements are copied to dest1
\item {\tt Sequence<Key, Info>\& dest2} - The second output sequence
\item {\tt int step2} - The number of entries to be copied to dest2 per turn
\item {\tt int count2} - The number of turns when elements are copied to dest2
\end{itemize}

\subsection{Output}

\begin{enumerate}
\item The initial {\tt start} elements are not to be copied anywhere.

\item  Past the initial {\tt start} elements, sequence nodes are to be copied
interchangeably to {\tt dest1} and {\tt dest2}, starting with the former.

\item  If {\tt count1} is 0 and it's {\tt dest1}'s turn, {\tt dest1} skips its
turn. The same applies to {\tt dest2}.

\item  If it's {\tt dest1}'s turn, {\tt step1} elements are to be copied to
{\tt dest1}. If there are not enough elements in {\tt source}, the maximum
possible amount of elements is copied and the algorithm terminates.
The same applies to {\tt dest2}.

\item  If it's {\tt dest1}'s turn, {\tt count1} is decremented. The same applies
to {\tt dest2}.

\item If both {\tt count1} and {\tt count2} are zero, the algorithm terminates.
\end{enumerate}

\subsection{Implementation}

The algorithm used to implement the function can be described as follows
(using pseudocode):

\begin{verbatim}
01 if start is greater or equal to source's length, terminate

02 obtain iterator of source at the beginning

03 increment iterator to start position

04 mark dest1 as output destination

05 if count1 > 0 or count2 > 0, continue, otherwise terminate

06 if outputting to dest1 and count1 is 0, go to 10
   if outputting to dest2 and count2 is 0, go to 10
   
07 if outputting to dest1, try to output step1 elements to dest1
   if outputting to dest2, try to output step2 elements to dest2

08 if end of source was reached mid-way, terminate

09 if outputting to dest1, decrement count1
   if outputting to dest2, decrement count2

10 switch output destination

11 go to 05

\end{verbatim}

\subsection{Example program output}

The following constitutes example program output, with line breaks inserted
for formatting.

\begin{verbatim}
Original sequence:
Key:  stays stays stays   dest1 dest1 dest2 dest2 dest2 dest1 
Info: 123   12345 1234567 31415 27182 2137  69    420   16180 

dest1 dest2 dest2 dest2 dest2 dest2
14142 1352  911   404   1337  8008135

Splitting: starting at 3, 2 elements to dest1 2 times,
3 elements to dest2 3 times

Destination 1:
Key:  dest1 dest1 dest1 dest1
Info: 31415 27182 16180 14142

Destination 2:
Key:  dest2 dest2 dest2 dest2 dest2 dest2 dest2 dest2
Info: 2137  69    420   1352  911   404   1337  8008135
\end{verbatim}

\end{document}
