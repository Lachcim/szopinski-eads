\documentclass{article}

\title{
	Keyed singly-linked list of two data types \\
	\large An EADS generic programming project report
}
\date{November 2019}
\author{Michał Szopiński}

\begin{document}

\maketitle

\section{Overview}

The goal of the project was to write a singly-linked list of nodes which would
emulate a collection of independent sequences, each distinguished with a unique
key. This was to be achieved using the class template mechanism offered by the
C++ programming language. The end goal was to design a container class whose
public members would facilitate the implementation of a function named
{\tt split}, which divides the container into two smaller ones, following
a set of rules.

The container in question is named {\tt Sequence} and can be used as follows:

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.push_back("my key", 123);
mySequence.push_back("my key", 456);
mySequence.push_back("my key", 789);
mySequence.erase(++(mySequence.begin("my key")));
\end{verbatim}

The above code allocates a new instance of {\tt Sequence} on the stack,
adds three elements to it, and then promptly removes the second element.
This particular instance is capable of holding keys of type {\tt const char*}
and info of type {\tt int}.

\subsection{The key-info mechanism and sublists}

The significance of the {\it key} parameter is that it groups elements together,
effectively separating the sequence into multiple independent lists, henceforth
called {\it sublists}. The modifiers provided by the class can therefore either
operate on one individual sublist, or all of them at once. As such, most public
members of {\tt Sequence} provide a parameter of type {\tt const Key\&}, which
is used to specify the key of the sublist that is to be modified. Some members,
such as {\tt size()}, provide no such parameter and operate on all sublists
simultaneously.

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.push_back("my key", 123);
mySequence.push_back("my key", 456);
mySequence.push_back("my key", 789);
mySequence.push_back("your key", 1234);
mySequence.push_back("your key", 1234);
mySequence.push_back("your key", 1234);
mySequence.clear("my key");
\end{verbatim}

In the above code, {\tt "my key"} was the only key impacted by the
{\tt clear(const Key\&)} method. After the final statement, three elements
remain in the sequence - all of which belonging to the sublist {\tt "your key"}.

\subsection{Key comparability and other requirements}

Because the class template mechanism allows all classes to be used as keys and
info entries, care must be taken to only use classes which are suitable for
this task. A suitable class is a class that meets all of the following criteria:

\begin{enumerate}
\item In the case of keys, two instances of the class can be meaningfully
compared using the {\tt ==} and {\tt !=} operators.
\item It has a default constructor of no parameters.
\item It has an effective copy constructor and a copy assignment operator.
\end{enumerate}

Failure to meet these criteria may produce unpredictable results or prevent
compilation altogether.

\subsection{Tail keeping mechanism and iterators}

In order to facilitate bulk insertion, a tail keeping mechanism was implemented
to keep track of the last element on the list. This reduced the time complexity
of final-element insertion from $O(n)$ (resulting from the need to traverse the
entire list) to $O(1)$. This, however, did not reduce the complexity of
final-element removal, which could only be improved by implementing a
doubly-linked list.

As a result of this disparity between accessing final and non-final elements,
an iterator class was added to the container to enable fast access to
consecutive nodes. {\tt Sequence<Key, Info>::iterator} is therefore a forward
iterator which can be used to efficiently traverse the list with a complexity of
$O(n)$, as opposed to $O(n^2)$ that's associated with continuous calls to
{\tt at()}.

\begin{verbatim}
//a sequence of 100000 elements
Sequence<const char*, int> mySequence;
for (int i = 0; i < 100000; i++)
    mySequence.add("my key", i);

for (int i = 0; i < 100000; i++)
    output = mySequence.at("my key", i); //5050555500 queries

Sequence<const char*, int>::iterator i;
for (i = mySequence.begin("my key"); i != mySequence.end(); ++i)
    output = *i; //100000 queries
\end{verbatim}

{\tt Sequence<Key, Info>::const\_iterator} is a constant version of this
iterator which does not permit any changes to the iterated sequence.

\subsection{Keyed and key-agnostic iterators}

Despite the fact that {\tt Sequence} is inherently designed to treat all of its
sublists independently, the requirements of the final task demanded that a
special interface is introduced to treat the sequence as a unitary "superlist".
This interface is known as a {\it key-agnostic iterator} and can be used to
transcend the boundaries of sublists when iterating over the sequence.
Like most public members of the class, iterators posses a parameter which limits
them to a single sublist: 

\begin{verbatim}
Sequence<const char*, int> mySequence;
mySequence.push_back("my key", 123);
mySequence.push_back("your key", 1234);
mySequence.push_back("his key", 4321);
mySequence.push_back("my key", 123);
mySequence.push_back("your key", 1234);
mySequence.push_back("his key", 4321);
mySequence.push_back("my key", 123);
mySequence.push_back("your key", 1234);
mySequence.push_back("his key", 4321);

Sequence<const char*, int>::iterator it;
for (it = mySequence.begin("his key"); it != mySequence.end(); ++it)
    printf("%s %d\n", it->key, it->info);
    //prints "his key 4321" three times

\end{verbatim}

A similar call to {\tt begin()} (without the parentheses) would return a
key-agnostic iterator, which would then produce nine different lines in the
output stream.
A key-agnostic iterator cannot be used to insert new elements with the
{\tt insert(iterator, const Info\&)} method, as it is not related to any sublist
and carries no information about its key. Similarly, the iterator returned by
{\tt end()} is also key-agnostic and cannot be used to push new elements to
the end of the list. In order to generate a keyed end iterator,
{\tt end(const Key\&)} can be called, which in turn can be used for insertion:

\begin{verbatim}
mySequence.insert(mySequence.end("her key"), 777);
\end{verbatim}

Despite these differences, however, all end iterators, keyed or not, compare
true to each other.

\begin{verbatim}
mySequence.end("her key") == mySequence.end() //true
\end{verbatim}

\subsection{Memory management considerations}

One of the key design features of the container is that it creates copies
of the elements passed into it and allocates them on the heap, automatically
managing them throughout its lifespan. While useful for storing multiple
instances of independent objects, developers must be wary of this feature if
they intend to store classes that are memory-intensive.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer> mySequence;
mySequence.push_back(1, buffer);
mySequence.push_back(2, buffer);
mySequence.push_back(3, buffer); //100 MB allocated on the heap by
                                 //four instances of ImageBuffer
\end{verbatim}

As shown above, improper use of {\tt Sequence} can easily lead to excessive
memory usage. When object independence isn't necessary, it may be preferable
to create a sequence of pointers instead.

\begin{verbatim}
//instance on the stack stores 25MB on the heap
ImageBuffer buffer(path);

Sequence<int, ImageBuffer*> mySequence;
mySequence.push_back(1, \&buffer);
mySequence.push_back(2, \&buffer);
mySequence.push_back(3, \&buffer); //25 MB allocated on the heap by
                                  //one instance of ImageBuffer
\end{verbatim}

\section{Template specification}

In the following section, function signatures are written in shorthand -
omitting the scope resolution operators and template syntax.

\subsection{{\tt Sequence<Key, Info>}}

\subsubsection{{\tt struct KeyInfoPair}}

A structure holding the key and the info of a given element. It's the value type
of the iterator.

\subsubsection{{\tt Sequence()}}

Default constructor. Creates an empty list.

\subsubsection{{\tt Sequence(other)}}

Copy constructor. Copies all elements of the other list.

\subsubsection{{\tt Sequence\& operator=(other)}}

Copy assignment operator. Deallocates all nodes of this list and copies all
nodes from the other list.

\subsubsection{{\tt \~{}Sequence()}}

Destructor. Deallocates all nodes on the list.

\subsubsection{{\tt class iterator} \\
	{\tt class const\_iterator}}

An powerful forward input-output iterator that allows the list to be traversed
with $O(n)$ complexity while respecting sublist boundaries, or ignoring them
if necessary. A detailed specification of this class can be found in the next
subsection.

\subsubsection{{\tt iterator begin()} \\
	{\tt iterator begin(const Key\&)} \\
	{\tt iterator cbegin() const} \\
	{\tt iterator cbegin(const Key\&) const}}
	
Returns an iterator pointing to the first element on the sublist. Overloads 1
and 3 are key-agnostic.

\subsubsection{{\tt iterator end()} \\
	{\tt iterator end(const Key\&)} \\
	{\tt iterator cend() const} \\
	{\tt iterator cend(const Key\&) const}}
	
Returns an iterator pointing to one element past the final item on the sublist.
Overloads 1 and 3 are key-agnostic.

\subsubsection{{\tt KeyInfoPair\& at(const Key\&, int)} \\
	{\tt const KeyInfoPair\& at(const Key\&, int) const}}
	
Returns a reference to the n-th element on the given sublist. In contrast to
the STL implementation of {\tt at()}, this method causes undefined behavior
when trying to access a nonexistent element.

\subsubsection{{\tt KeyInfoPair\& front(const Key\&)} \\
	{\tt const KeyInfoPair\& front(const Key\&) const}}
	
Returns a reference to the first element on the given sublist. Causes undefined
behavior when no such element is found.

\subsubsection{{\tt KeyInfoPair\& back(const Key\&)} \\
	{\tt const KeyInfoPair\& back(const Key\&) const}}
	
Returns a reference to the last element on the given sublist. Causes undefined
behavior when no such element is found.

\subsubsection{{\tt int size() const} \\
	{\tt int size(const Key\&) const}}
	
Returns the number of items in the given sublist. Overload 1 (for the entire
sequence) has a complexity of $O(1)$, overload 2 has a complexity of $O(n)$.

\subsubsection{{\tt bool empty() const} \\
	{\tt bool empty(const Key\&) const}}
	
Checks whether the given sublist is empty. Overload 1 (for the entire sequence)
has a complexity of $O(1)$, overload 2 has a complexity of $O(n)$.

\subsubsection{{\tt iterator insert(iterator, const Info\&)}}
	
Inserts a new node with the given info data before the specified element. Has
no effect for key-agnostic iterators. $O(1)$ complexity for final-element
insertions, $O(n)$ complexity for all other positions. Returns an iterator to
the newly inserted element.

\subsubsection{{\tt iterator erase(iterator}}
	
Erases the element at the given position with $O(n)$ complexity. Accepts
key-agnostic iterators. Returns an iterator to the element following the erased
element.

\subsubsection{{\tt void push\_back(const Key\&, const Info\&)} \\
	{\tt void push\_back(const KeyInfoPair\&)}}
	
Inserts a new element at the end of the given sublist. $O(1)$ complexity.

\subsubsection{{\tt void push\_front(const Key\&, const Info\&)} \\
	{\tt void push\_front(const KeyInfoPair\&)}}
	
Inserts a new element at the start of the given sublist.

\subsubsection{{\tt void pop\_back(const Key\&)}}

Erases the last element in the given sublist. Undefined behavior for empty
lists.

\subsubsection{{\tt void pop\_front(const Key\&)}}

Erases the first element in the given sublist. Undefined behavior for empty
lists.

\subsubsection{{\tt void clear()} \\
	{\tt void clear(const Key\&)}}

Erases all elements in the given sublist.

\subsection{{\tt Sequence<Key, Info>::iterator} \\
{\tt Sequence<Key, Info>::const\_iterator}}

\subsubsection{{\tt iterator()} \\
	{\tt const\_iterator()}}

Default constructor. Creates a key-agnostic end iterator.

\subsubsection{{\tt bool isKeyed() const}}

Checks whether the iterator is keyed, i.e. whether it follows sublist
boundaries.

\subsubsection{{\tt Key getKey() const}}

Returns the key of the keyed iterator. For key-agnostic iterators, returns an
instance of the key constructed with no parameters.

\section{Implementation of the {\tt split} function}

With the help of the aforementioned features, it was possible to implement the
{\tt split} function in an efficient and elegant manner. Linear-time list
traversal combined with constant-time final insertion reduced the
time-complexity of {\tt split} to $O(n)$.

\subsection{Input}

The function accepts the following input parameters:

\begin{itemize}
\item {\tt const Sequence<Key, Info>\& source} - The sequence to be split
\item {\tt int start} - The number of initial entries to be omitted
\item {\tt Sequence<Key, Info>\& dest1} - The first output sequence
\item {\tt int step1} - The number of entries to be copied to dest1 per turn
\item {\tt int count1} - The number of turns when elements are copied to dest1
\item {\tt Sequence<Key, Info>\& dest2} - The second output sequence
\item {\tt int step2} - The number of entries to be copied to dest2 per turn
\item {\tt int count2} - The number of turns when elements are copied to dest2
\end{itemize}

\subsection{Output}

\begin{enumerate}
\item The initial {\tt start} elements are not to be copied anywhere.

\item  Past the initial {\tt start} elements, sequence nodes are to be copied
interchangeably to {\tt dest1} and {\tt dest2}, starting with the former.

\item  If {\tt count1} is 0 and it's {\tt dest1}'s turn, {\tt dest1} skips its
turn. The same applies to {\tt dest2}.

\item  If it's {\tt dest1}'s turn, {\tt step1} elements are to be copied to
{\tt dest1}. If there are not enough elements in {\tt source}, the maximum
possible amount of elements is copied and the algorithm terminates.
The same applies to {\tt dest2}.

\item  If it's {\tt dest1}'s turn, {\tt count1} is decremented. The same applies
to {\tt dest2}.

\item If both {\tt count1} and {\tt count2} are zero, the algorithm terminates.
\end{enumerate}

\subsection{Implementation}

The algorithm used to implement the function can be described as follows
(using pseudocode):

\begin{verbatim}
01 if start is greater or equal to source's length, terminate

02 obtain iterator of source at the beginning

03 increment iterator to start position

04 mark dest1 as output destination

05 if count1 > 0 or count2 > 0, continue, otherwise terminate

06 if outputting to dest1 and count1 is 0, go to 10
   if outputting to dest2 and count2 is 0, go to 10
   
07 if outputting to dest1, try to output step1 elements to dest1
   if outputting to dest2, try to output step2 elements to dest2

08 if end of source was reached mid-way, terminate

09 if outputting to dest1, decrement count1
   if outputting to dest2, decrement count2

10 switch output destination

11 go to 05

\end{verbatim}

\subsection{Example program output}

The following constitutes example program output, with line breaks inserted
for formatting.

\begin{verbatim}
Original sequence:
Key:  stays stays stays   dest1 dest1 dest2 dest2 dest2 dest1 
Info: 123   12345 1234567 31415 27182 2137  69    420   16180 

dest1 dest2 dest2 dest2 dest2 dest2
14142 1352  911   404   1337  8008135

Splitting: starting at 3, 2 elements to dest1 2 times,
3 elements to dest2 3 times

Destination 1:
Key:  dest1 dest1 dest1 dest1
Info: 31415 27182 16180 14142

Destination 2:
Key:  dest2 dest2 dest2 dest2 dest2 dest2 dest2 dest2
Info: 2137  69    420   1352  911   404   1337  8008135
\end{verbatim}

\end{document}
